import { expect } from 'chai'
import * as pattern from './pattern'

describe('unit: pattern', () => {
  it('default', async () => {
    expect(pattern.default('/foo/{name+}', '/{name}', '/foo/bar/baz')).to.equal('/bar/baz')
    expect(pattern.default('/foo/*', '/foobar', '/foo/bar')).to.equal('/foobar')
  })

  it('getRegex', async () => {
    expect(pattern.getRegex(/.*/)).to.deep.equal(/.*/)
    expect(pattern.getRegex('*')).to.deep.equal(/^[^\s]*$/i)
    expect(pattern.getRegex(pattern.parse('*'))).to.deep.equal(/^[^\s]*$/i)
    expect(() => pattern.getRegex(1)).to.throw()
  })

  it('escape', async () => {
    expect(pattern.escape('a-z')).to.equal('a-z')
    expect(pattern.escape('[foo]')).to.equal('\\[foo\\]')
    expect(pattern.escape('foo{bar}baz')).to.equal('foo\\{bar\\}baz')
    expect(pattern.escape('foo**bar')).to.equal('foo\\*\\*bar')
  })

  it('match', async () => {
    expect(pattern.match('/*', '/a')).to.equal(true)
    expect(pattern.match('/{name+}', '/foo/bar')).to.equal(true)
    expect(pattern.match('/foo/{name+}', '/foo')).to.equal(false)
    expect(pattern.match(pattern.parse('/*'), '/a')).to.equal(true)
    expect(pattern.match(/foo.*/, '/foo/bar')).to.equal(true)
    expect(pattern.match(/foo.*/, '/baz')).to.equal(false)
    expect(() => pattern.match({}, '/a')).to.throw()
  })

  it('findMatch', async () => {
    const patterns = ['foo/*', 'bar/*', 'baz/*']
    expect(pattern.findMatch(patterns, 'foo/a')).to.deep.equal({ matched: true, index: 0 })
    expect(pattern.findMatch(patterns, 'bar/a/b')).to.deep.equal({ matched: true, index: 1 })
    expect(pattern.findMatch(patterns, 'baz/a/b/c')).to.deep.equal({ matched: true, index: 2 })
    expect(pattern.findMatch(patterns, 'foobar')).to.deep.equal(undefined)
    expect(() => pattern.findMatch('a', 'foobar')).to.throw()
  })

  it('parse', async () => {
    expect(pattern.parse('/a')).to.deep.equal({ pattern: '/a', keys: [], regex: /^\/a$/i })
    expect(pattern.parse('/a/b')).to.deep.equal({ pattern: '/a/b', keys: [], regex: /^\/a\/b$/i })
    expect(pattern.parse('/{a}')).to.deep.equal({ pattern: '/{a}', keys: ['a'], regex: /^\/([^/\s]+?)$/i })
    expect(pattern.parse('/*')).to.deep.equal({ pattern: '/*', keys: [], regex: /^\/[^\s]*$/i })
    expect(pattern.parse('/**')).to.deep.equal({ pattern: '/**', keys: [], regex: /^\/[^\s]*[^\s]*$/i })
    expect(pattern.parse('/*/*')).to.deep.equal({ pattern: '/*/*', keys: [], regex: /^\/[^\s]*\/[^\s]*$/i })
    expect(pattern.parse('/a*')).to.deep.equal({ pattern: '/a*', keys: [], regex: /^\/a[^\s]*$/i })
    expect(pattern.parse('/*a')).to.deep.equal({ pattern: '/*a', keys: [], regex: /^\/[^\s]*a$/i })
    expect(pattern.parse('/*a*')).to.deep.equal({ pattern: '/*a*', keys: [], regex: /^\/[^\s]*a[^\s]*$/i })
    expect(pattern.parse('/{a}/*')).to.deep.equal({ pattern: '/{a}/*', keys: ['a'], regex: /^\/([^/\s]+?)\/[^\s]*$/i })
    expect(pattern.parse('/*/{a}')).to.deep.equal({ pattern: '/*/{a}', keys: ['a'], regex: /^\/[^\s]*\/([^/\s]+?)$/i })
    expect(pattern.parse('/a{b}')).to.deep.equal({ pattern: '/a{b}', keys: ['b'], regex: /^\/a([^/\s]+?)$/i })
    expect(pattern.parse('/a{b}')).to.deep.equal({ pattern: '/a{b}', keys: ['b'], regex: /^\/a([^/\s]+?)$/i })
    expect(pattern.parse('/{a}b')).to.deep.equal({ pattern: '/{a}b', keys: ['a'], regex: /^\/([^/\s]+?)b$/i })
    expect(pattern.parse('/*a{b}')).to.deep.equal({ pattern: '/*a{b}', keys: ['b'], regex: /^\/[^\s]*a([^/\s]+?)$/i })
    expect(pattern.parse('/{a_a}')).to.deep.equal({ pattern: '/{a_a}', keys: ['a_a'], regex: /^\/([^/\s]+?)$/i })
    expect(pattern.parse('/{a?}')).to.deep.equal({ pattern: '/{a?}', keys: ['a'], regex: /^\/([^/\s]+?)?$/i })
    expect(pattern.parse('/{a+}')).to.deep.equal({ pattern: '/{a+}', keys: ['a'], regex: /^\/([^\s]+?)$/i })
    expect(pattern.parse('/*/{a+}')).to.deep.equal({ pattern: '/*/{a+}', keys: ['a'], regex: /^\/[^\s]*\/([^\s]+?)$/i })
    expect(pattern.parse('/{a}-{ab}')).to.deep.equal({ pattern: '/{a}-{ab}', keys: ['a', 'ab'], regex: /^\/([^/\s]+?)-([^/\s]+?)$/i })
    expect(pattern.parse('/{a}-*')).to.deep.equal({ pattern: '/{a}-*', keys: ['a'], regex: /^\/([^/\s]+?)-[^\s]*$/i })
    expect(pattern.parse('/*-{a}')).to.deep.equal({ pattern: '/*-{a}', keys: ['a'], regex: /^\/[^\s]*-([^/\s]+?)$/i })
    expect(pattern.parse('/{ab}-{cd}-{efg}')).to.deep.equal({ pattern: '/{ab}-{cd}-{efg}', keys: ['ab', 'cd', 'efg'], regex: /^\/([^/\s]+?)-([^/\s]+?)-([^/\s]+?)$/i })
    expect(pattern.parse('/{a}-{ab+}')).to.deep.equal({ pattern: '/{a}-{ab+}', keys: ['a', 'ab'], regex: /^\/([^/\s]+?)-([^\s]+?)$/i })
    expect(pattern.parse('/*-{ab+}')).to.deep.equal({ pattern: '/*-{ab+}', keys: ['ab'], regex: /^\/[^\s]*-([^\s]+?)$/i })
    expect(pattern.parse('/{a+}/{b}')).to.deep.equal({ pattern: '/{a+}/{b}', keys: ['a', 'b'], regex: /^\/([^\s]+?)\/([^/\s]+?)$/i })
    expect(pattern.parse('/{a+}/{b+}')).to.deep.equal({ pattern: '/{a+}/{b+}', keys: ['a', 'b'], regex: /^\/([^\s]+?)\/([^\s]+?)$/i })
    expect(pattern.parse('/{a?}-{b}')).to.deep.equal({ pattern: '/{a?}-{b}', keys: ['a', 'b'], regex: /^\/([^/\s]+?)?-([^/\s]+?)$/i })
    expect(pattern.parse('/{aaa+}-{b}')).to.deep.equal({ pattern: '/{aaa+}-{b}', keys: ['aaa', 'b'], regex: /^\/([^\s]+?)-([^/\s]+?)$/i })
    expect(pattern.parse('/{aaa+}-{b}-{c}')).to.deep.equal({ pattern: '/{aaa+}-{b}-{c}', keys: ['aaa', 'b', 'c'], regex: /^\/([^\s]+?)-([^/\s]+?)-([^/\s]+?)$/i })
    expect(pattern.parse('/{a+}-{bbb}')).to.deep.equal({ pattern: '/{a+}-{bbb}', keys: ['a', 'bbb'], regex: /^\/([^\s]+?)-([^/\s]+?)$/i })
    expect(pattern.parse('/{a+}^{b}')).to.deep.equal({ pattern: '/{a+}^{b}', keys: ['a', 'b'], regex: /^\/([^\s]+?)\^([^/\s]+?)$/i })
    expect(pattern.parse('/{a+}-{b+}')).to.deep.equal({ pattern: '/{a+}-{b+}', keys: ['a', 'b'], regex: /^\/([^\s]+?)-([^\s]+?)$/i })
    expect(pattern.parse('/{a}/{b}')).to.deep.equal({ pattern: '/{a}/{b}', keys: ['a', 'b'], regex: /^\/([^/\s]+?)\/([^/\s]+?)$/i })
    expect(pattern.parse('/a/{b}')).to.deep.equal({ pattern: '/a/{b}', keys: ['b'], regex: /^\/a\/([^/\s]+?)$/i })
    expect(pattern.parse('/a/*/{b}')).to.deep.equal({ pattern: '/a/*/{b}', keys: ['b'], regex: /^\/a\/[^\s]*\/([^/\s]+?)$/i })
    expect(pattern.parse('/a/{b}/{c}')).to.deep.equal({ pattern: '/a/{b}/{c}', keys: ['b', 'c'], regex: /^\/a\/([^/\s]+?)\/([^/\s]+?)$/i })
    expect(pattern.parse('/{a}/b/{c}')).to.deep.equal({ pattern: '/{a}/b/{c}', keys: ['a', 'c'], regex: /^\/([^/\s]+?)\/b\/([^/\s]+?)$/i })
    expect(pattern.parse('/a/{b}-{c}')).to.deep.equal({ pattern: '/a/{b}-{c}', keys: ['b', 'c'], regex: /^\/a\/([^/\s]+?)-([^/\s]+?)$/i })
    expect(pattern.parse('/a$')).to.deep.equal({ pattern: '/a$', keys: [], regex: /^\/a\$$/i })
    expect(pattern.parse('/{a')).to.deep.equal({ pattern: '/{a', keys: [], regex: /^\/\{a$/i })
    expect(pattern.parse('/a(b)')).to.deep.equal({ pattern: '/a(b)', keys: [], regex: /^\/a\(b\)$/i })
    expect(() => pattern.parse('/{a}{b}')).to.throw()
    expect(() => pattern.parse('/{a}*')).to.throw()
    expect(() => pattern.parse('/*{a}')).to.throw()
    expect(() => pattern.parse('/{a}/{a}')).to.throw()
    expect(() => pattern.parse('/{a b}')).to.throw()
    expect(() => pattern.parse('/{a*b}')).to.throw()
    expect(() => pattern.parse('/{*a}')).to.throw()
    expect(() => pattern.parse('/{?a}')).to.throw()
    expect(() => pattern.parse('/{ab!}')).to.throw()
    expect(() => pattern.parse('/{a$b}')).to.throw()
    expect(() => pattern.parse('/{a-b}')).to.throw()
    expect(() => pattern.parse('/{ab*?}')).to.throw()
    expect(() => pattern.parse('/{ab?*}')).to.throw()
    expect(() => pattern.parse('/{*}')).to.throw()
    expect(() => pattern.parse('/{?}')).to.throw()
    expect(() => pattern.parse('/{+}')).to.throw()
    expect(() => pattern.parse('/{}')).to.throw()
    expect(() => pattern.parse(/.*/)).to.throw(TypeError)
  })

  it('extract', async () => {
    expect(pattern.extract(pattern.parse('/a'), '/a')).to.deep.equal({})
    expect(pattern.extract(pattern.parse('/*'), '/a/b')).to.deep.equal({})
    expect(pattern.extract(pattern.parse('/a/b'), '/a/b')).to.deep.equal({})
    expect(pattern.extract(pattern.parse('/{a}'), '/foo')).to.deep.equal({ a: 'foo' })
    expect(pattern.extract(pattern.parse('/*/{a}'), '/foo/bar/baz')).to.deep.equal({ a: 'baz' })
    expect(pattern.extract(pattern.parse('/a{b}'), '/afoo')).to.deep.equal({ b: 'foo' })
    expect(pattern.extract(pattern.parse('/*a{b}'), '/wafoo')).to.deep.equal({ b: 'foo' })
    expect(pattern.extract(pattern.parse('/{a}b'), '/foob')).to.deep.equal({ a: 'foo' })
    expect(pattern.extract(pattern.parse('/{a_a}'), '/foo')).to.deep.equal({ a_a: 'foo' })
    expect(pattern.extract(pattern.parse('/{a?}'), '/')).to.deep.equal({ a: '' })
    expect(pattern.extract(pattern.parse('/{a?}'), '/foo')).to.deep.equal({ a: 'foo' })
    expect(pattern.extract(pattern.parse('/{a+}'), '/foo')).to.deep.equal({ a: 'foo' })
    expect(pattern.extract(pattern.parse('/a/{c+}'), '/a/foo/bar')).to.deep.equal({ c: 'foo/bar' })
    expect(pattern.extract(pattern.parse('/a/*/{c+}'), '/a/foo/bar/baz')).to.deep.equal({ c: 'baz' })
    expect(pattern.extract(pattern.parse('/{a+}'), '/foo/bar')).to.deep.equal({ a: 'foo/bar' })
    expect(pattern.extract(pattern.parse('/{a}-{hello}'), '/foo-bar')).to.deep.equal({ a: 'foo', hello: 'bar' })
    expect(pattern.extract(pattern.parse('/{a}-{b+}'), '/foo-bar/baz')).to.deep.equal({ a: 'foo', b: 'bar/baz' })
    expect(pattern.extract(pattern.parse('/{a+}-{b}'), '/foo/bar-baz')).to.deep.equal({ a: 'foo/bar', b: 'baz' })
    expect(pattern.extract(pattern.parse('/{a}/{b}'), '/foo/bar')).to.deep.equal({ a: 'foo', b: 'bar' })
    expect(pattern.extract(pattern.parse('/{a}/*'), '/foo/bar')).to.deep.equal({ a: 'foo' })
    expect(pattern.extract(pattern.parse('/*/{a}'), '/foo/bar')).to.deep.equal({ a: 'bar' })
    expect(pattern.extract(pattern.parse('/a/{b}'), '/a/bar')).to.deep.equal({ b: 'bar' })
    expect(pattern.extract(pattern.parse('/a{b?}'), '/a')).to.deep.equal({ b: '' })
    expect(pattern.extract(pattern.parse('/*a{b?}'), '/afoo')).to.deep.equal({ b: 'foo' })
    expect(pattern.extract(pattern.parse('/*a{b?}'), '/aaaaafoo')).to.deep.equal({ b: 'foo' })
    expect(pattern.extract(pattern.parse('/a/{b}/{c}'), '/a/foo/bar')).to.deep.equal({ b: 'foo', c: 'bar' })
    expect(pattern.extract(pattern.parse('/{a}/b/{c}'), '/foo/b/bar')).to.deep.equal({ a: 'foo', c: 'bar' })
    expect(pattern.extract(pattern.parse('/a/{b}-{c}'), '/a/foo-bar')).to.deep.equal({ b: 'foo', c: 'bar' })
    expect(pattern.extract(pattern.parse('/a$/{b}'), '/a$/foo')).to.deep.equal({ b: 'foo' })
    expect(pattern.extract(pattern.parse('/{a}/b{'), '/foo/b{')).to.deep.equal({ a: 'foo' })
    expect(() => pattern.extract(pattern.parse('a'), 'foo')).to.throw()
    expect(() => pattern.extract(pattern.parse('/{a*}'), '/')).to.throw()
  })

  it('extract (regex)', async () => {
    expect(pattern.extract(/foo\/(.*)/, '/foo/bar')).to.deep.equal({ 1: 'bar' })
    expect(pattern.extract(/foo\/(?:.*)\/(.*)/, '/foo/bar/baz')).to.deep.equal({ 1: 'baz' })
    expect(pattern.extract(/foo\/(.*)\/(.*)/, '/foo/bar/baz')).to.deep.equal({ 1: 'bar', 2: 'baz' })
    expect(pattern.extract(/(foo)\/(.*)\/(.*)/, '/foo/bar/baz')).to.deep.equal({ 1: 'foo', 2: 'bar', 3: 'baz' })
    expect(() => pattern.extract(/hello(.*)/, '/foo/bar')).to.throw()
    expect(() => pattern.extract({}, '/foo/bar')).to.throw()
  })

  it('render', async () => {
    expect(pattern.render(pattern.parse('/a/b'))).to.equal('/a/b')
    expect(pattern.render(pattern.parse('/{a}'))).to.equal('/')
    expect(pattern.render(pattern.parse('/{a}'), { a: 'foo' })).to.equal('/foo')
    expect(pattern.render(pattern.parse('/{a+}'), { a: 'foo' })).to.equal('/foo')
    expect(pattern.render(pattern.parse('/{a?}'), { a: 'foo' })).to.equal('/foo')
    expect(pattern.render(pattern.parse('/a{b}'), { b: 'foo' })).to.equal('/afoo')
    expect(pattern.render(pattern.parse('/{a}b'), { a: 'foo' })).to.equal('/foob')
    expect(pattern.render(pattern.parse('/{a_a}'), { a_a: 'foo' })).to.equal('/foo')
    expect(pattern.render(pattern.parse('/{a}-{bcdef}'), { a: 'foo', bcdef: 'bar' })).to.equal('/foo-bar')
    expect(pattern.render(pattern.parse('/{a} {b}'), { a: 'foo', b: 'bar' })).to.equal('/foo bar')
    expect(pattern.render(pattern.parse('/{a}/{b}'), { a: 'foo', b: 'bar' })).to.equal('/foo/bar')
    expect(pattern.render(pattern.parse('/a/{b}'), { b: 'foo' })).to.equal('/a/foo')
    expect(pattern.render(pattern.parse('/a/{b}/{c}'), { b: 'foo', c: 'bar' })).to.equal('/a/foo/bar')
    expect(pattern.render(pattern.parse('/{a}/b/{c}'), { a: 'foo', c: 'bar' })).to.equal('/foo/b/bar')
    expect(pattern.render(pattern.parse('/a/{b}-{c}'), { b: 'foo', c: 'bar' })).to.equal('/a/foo-bar')
    expect(pattern.render(pattern.parse('/a$/{b}'), { b: 'foo' })).to.equal('/a$/foo')
    expect(pattern.render(pattern.parse('/{a}'), { b: 'foo' })).to.equal('/')
    expect(pattern.render(pattern.parse('/{a}'), { a: 'bár' })).to.equal('/bár')
    expect(pattern.render(pattern.parse('/{a}/b{'), { a: 'foo' })).to.equal('/foo/b{')
    expect(pattern.render(pattern.parse('/{1}/{2}'), { 1: 'foo', 2: 'bar' })).to.equal('/foo/bar')
    expect(() => pattern.render(pattern.parse('/a/*'))).to.throw()
    expect(() => pattern.render('hello')).to.throw()
  })
})
