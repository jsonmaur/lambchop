import { expect } from 'chai'
import * as pattern from './pattern'

describe('unit: pattern', () => {
  it('escapeRegex', async () => {
    expect(pattern.escapeRegex('[a-z]')).to.equal('\\[a\\-z\\]')
    expect(pattern.escapeRegex('hello**hi')).to.equal('hello\\*\\*hi')
  })

  it('matches', async () => {
    expect(pattern.matches('/*', '/hello')).to.equal(true)
    expect(pattern.matches('/**', '/hello')).to.equal(true)
    expect(pattern.matches('/*', '/hello/hi')).to.equal(false)
    expect(pattern.matches('/**', '/hello/hi')).to.equal(true)
    expect(pattern.matches('/**', '/hello/hi/')).to.equal(true)
    expect(pattern.matches('/**', '/really/long/path/yo')).to.equal(true)
    expect(pattern.matches('/hello', '/hello')).to.equal(true)
    expect(pattern.matches('/hello*', '/helloo')).to.equal(true)
    expect(pattern.matches('/hello*', '/hello/')).to.equal(false)
    expect(pattern.matches('/hello**', '/hello/')).to.equal(true)
    expect(pattern.matches('/hello*', '/hello/hi')).to.equal(false)
    expect(pattern.matches('/hello**', '/hello/hi')).to.equal(true)
    expect(pattern.matches('/{name}', '/')).to.equal(false)
    expect(pattern.matches('/{name}', '/jane')).to.equal(true)
    expect(pattern.matches('/hello/{name}', '/hello/jane')).to.equal(true)
    expect(pattern.matches('/hello/{name}', '/hello/')).to.equal(false)
    expect(pattern.matches('/hello-{name}', '/hello-jane')).to.equal(true)
    expect(pattern.matches('/he*o-{name}', '/heyo-jane')).to.equal(true)
    expect(pattern.matches('/he*o-{name}', '/hello-jane')).to.equal(true)
    expect(pattern.matches('/he*o-{name}', '/heo-jane')).to.equal(true)
    expect(pattern.matches('/he*o-{name}', '/he-jane')).to.equal(false)
    expect(pattern.matches('/hello-{first-name}', '/hello-jane')).to.equal(false)
    expect(pattern.matches('/hello-{first_name}', '/hello-jane')).to.equal(true)
    expect(pattern.matches('/hello-{first$name}', '/hello-jane')).to.equal(false)
    expect(pattern.matches('/hello-{first(name)}', '/hello-jane')).to.equal(false)
    expect(pattern.matches(/\.jpg$/, '/hi.jpg')).to.equal(true)
    expect(pattern.matches(/\.jpg$/, '/hi.jp')).to.equal(false)
  })

  it('toRegex', async () => {
    expect(pattern.toRegex('/{name}').source).to.equal('^\\/([^\\/\\s]+)$')
    expect(pattern.toRegex('/{fname}-{lname}').source).to.equal('^\\/([^\\/\\s]+)\\-([^\\/\\s]+)$')
    expect(pattern.toRegex('/hello{name}').source).to.equal('^\\/hello([^\\/\\s]+)$')
    expect(pattern.toRegex('/hello/{name}').source).to.equal('^\\/hello\\/([^\\/\\s]+)$')
    expect(pattern.toRegex('/hello/{name}/').source).to.equal('^\\/hello\\/([^\\/\\s]+)\\/$')
    expect(pattern.toRegex('/hello$').source).to.equal('^\\/hello\\$$')
    expect(pattern.toRegex('/hell(o)').source).to.equal('^\\/hell\\(o\\)$')
    expect(pattern.toRegex('/hello*').source).to.equal('^\\/hello([^\\/\\s]*)$')
    expect(pattern.toRegex('/hello**').source).to.equal('^\\/hello([^\\s]*)$')
    expect(pattern.toRegex('/he*llo*').source).to.equal('^\\/he([^\\/\\s]*)llo([^\\/\\s]*)$')
    expect(pattern.toRegex('/he**llo*').source).to.equal('^\\/he([^\\s]*)llo([^\\/\\s]*)$')
    expect(pattern.toRegex('/he**llo**').source).to.equal('^\\/he([^\\s]*)llo([^\\s]*)$')
    expect(pattern.toRegex('/hello/*').source).to.equal('^\\/hello\\/([^\\/\\s]*)$')
    expect(pattern.toRegex('/hello/**').source).to.equal('^\\/hello\\/([^\\s]*)$')
    expect(pattern.toRegex('/hello/*/hi').source).to.equal('^\\/hello\\/([^\\/\\s]*)\\/hi$')
    expect(pattern.toRegex('/hello*/**/hi').source).to.equal('^\\/hello([^\\/\\s]*)\\/([^\\s]*)\\/hi$')
    expect(pattern.toRegex('/*').source).to.equal('^\\/([^\\/\\s]*)$')
    expect(pattern.toRegex('/**').source).to.equal('^\\/([^\\s]*)$')
    expect(() => pattern.toRegex('/***')).to.throw()
    expect(() => pattern.toRegex('/hello***')).to.throw()
    expect(() => pattern.toRegex('/{name}*')).to.throw()
    expect(() => pattern.toRegex('/*{name}')).to.throw()
    expect(() => pattern.toRegex('/{hi}{hey}')).to.throw()
  })

  it('extract (wildcards/segments)', async () => {
    expect(pattern.extract('/', '/*')).to.deep.equal({})
    expect(pattern.extract('/hi', '/*')).to.deep.equal({ $1: 'hi' })
    expect(pattern.extract('/hi/hey', '/**')).to.deep.equal({ $1: 'hi/hey' })
    expect(pattern.extract('/hi/hey', '/*/hey')).to.deep.equal({ $1: 'hi' })
    expect(pattern.extract('/hi/hey/yo', '/*/**')).to.deep.equal({ $1: 'hi', $2: 'hey/yo' })
    expect(pattern.extract('/janedoe', '/jane*')).to.deep.equal({ $1: 'doe' })
    expect(pattern.extract('/jane/doe', '/jane**')).to.deep.equal({ $1: '/doe' })
    expect(pattern.extract('/jane', '/{name}')).to.deep.equal({ name: 'jane' })
    expect(pattern.extract('/jane-doe', '/jane-{lname}')).to.deep.equal({ lname: 'doe' })
    expect(pattern.extract('/jane-doe', '/{fname}-{lname}')).to.deep.equal({ fname: 'jane', lname: 'doe' })
    expect(pattern.extract('/my/name/is/jane', '/**/{name}')).to.deep.equal({ $1: 'my/name/is', name: 'jane' })
    expect(pattern.extract('/hi/hijane/doe/yo/yo', '/*/hi{fname}/{lname}/**')).to.deep.equal({ $1: 'hi', $2: 'yo/yo', fname: 'jane', lname: 'doe' })
    expect(() => pattern.extract('/hello', '/hello/{name}')).to.throw()
    expect(() => pattern.extract('/hi', '/***')).to.throw()
    expect(() => pattern.extract('/hi', '/{name}**')).to.throw()
    expect(() => pattern.extract('/janedoe', '/{fname}{lname}')).to.throw()
    expect(() => pattern.extract('/jane/doe', '/{name}/{name}')).to.throw()
  })

  it('extract (regex)', async () => {
    expect(pattern.extract('/hello/hi', /^\/(.*)\/(.*)$/)).to.deep.equal({ $1: 'hello', $2: 'hi' })
    expect(pattern.extract('/my/name/is/jane', /^\/my\/.*\/is\/(.+)/)).to.deep.equal({ $1: 'jane' })
    expect(pattern.extract('/hello', /(.*)/)).to.deep.equal({ $1: '/hello' })
    expect(pattern.extract('/hello', /.*/)).to.deep.equal({})
    expect(() => pattern.extract('/hello', /^a/)).to.throw()
  })

  it('render', async () => {
    const data = { $1: 'whatup', $2: 'yo', fname: 'jane', lname: 'doe' }
    expect(pattern.render('/$1', data)).to.equal('/whatup')
    expect(pattern.render('/$1$2', data)).to.equal('/whatupyo')
    expect(pattern.render('/$1/$2', data)).to.equal('/whatup/yo')
    expect(pattern.render('/hello/$2', data)).to.equal('/hello/yo')
    expect(pattern.render('/{fname}', data)).to.equal('/jane')
    expect(pattern.render('/{fname}{lname}', data)).to.equal('/janedoe')
    expect(pattern.render('/{fname}/{lname}', data)).to.equal('/jane/doe')
    expect(pattern.render('/hello/{fname}', data)).to.equal('/hello/jane')
    expect(pattern.render('/$1{lname}', data)).to.equal('/whatupdoe')
    expect(pattern.render('/{fname}$2', data)).to.equal('/janeyo')
    expect(pattern.render('/$1{fname}$2-{lname}', data)).to.equal('/whatupjaneyo-doe')
    expect(pattern.render(`/\${fname}`, data)).to.equal('/$jane')
    expect(pattern.render('/{yo$2', data)).to.equal('/{yoyo')
    expect(pattern.render('/{$1}', data)).to.equal('/whatup')
    expect(() => pattern.render('/$3', data)).to.throw()
    expect(() => pattern.render('/hello/{wazzup}', data)).to.throw()
    expect(() => pattern.render('/{$4}', data)).to.throw()
  })
})
